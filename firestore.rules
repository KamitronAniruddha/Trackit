
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---
    function isSignedIn() {
      return request.auth != null;
    }

    function getRole() {
        return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
    }

    function isAdmin() {
      return isSignedIn() && getRole() == 'admin';
    }

    function isSubAdmin() {
        return isSignedIn() && getRole() == 'subadmin';
    }

    function hasAdminPrivileges() {
        let role = getRole();
        return isSignedIn() && (role == 'admin' || role == 'subadmin');
    }
    
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    // NEW SPECTATE HELPER
    function canSpectate(userId) {
        let user = get(/databases/$(database)/documents/users/$(userId)).data;
        return hasAdminPrivileges() &&
               'spectatePermission' in user &&
               user.spectatePermission.status == 'granted' &&
               user.spectatePermission.expiresAt > request.time;
    }

    // --- Collection Rules ---

    match /users/{userId} {
      // CREATE: A newly authenticated user can create their own document.
      allow create: if isOwner(userId);

      // GET: Owners can read their own doc. Admins can read any doc if they can spectate.
      // Other signed-in users can read non-deleted profiles.
      allow get: if isOwner(userId) || canSpectate(userId) || (isSignedIn() && resource.data.get('isDeleted', false) == false);

      // LIST: Admins can list users. Client must filter by spectate permission.
      allow list: if isSignedIn();

      // UPDATE:
      allow update: if 
        // Case A: Admin performing moderation on non-admin user
        (hasAdminPrivileges() && resource.data.role != 'admin' && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isBanned', 'banExpiresAt', 'isPremium', 'accountStatus', 'hasPendingUnbanRequest', 'role'])) ||
        
        // Case B: Owner updating their own profile
        (isOwner(userId) && resource.data.get('isDeleted', false) == false && (
          // Sub-case B1: Normal profile update (any field EXCEPT protected ones)
          (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['role', 'isBanned', 'isDeleted', 'banExpiresAt', 'accessCode', 'isPremium', 'accountStatus', 'spectatePermission'])) ||
          
          // Sub-case B2: User granting/revoking spectate permission
          (
            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['spectatePermission']) &&
            // User cannot set the spectatingAdminId themselves. It must be null or same as before.
            request.resource.data.spectatePermission.get('spectatingAdminId', null) == resource.data.spectatePermission.get('spectatingAdminId', null)
          ) ||

          // Sub-case B3: Premium activation via one-time code.
          (
            request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isPremium', 'accountStatus']) &&
            resource.data.isPremium == false && request.resource.data.isPremium == true &&
            resource.data.accountStatus == 'demo' && request.resource.data.accountStatus == 'active'
          )
        )) ||

        // Case C: Admin starting/stopping a spectate session
        (canSpectate(userId) &&
          request.resource.data.diff(resource.data).affectedKeys().hasOnly(['spectatePermission']) &&
          // Admin can only change spectatingAdminId, not other permission fields
          request.resource.data.spectatePermission.status == resource.data.spectatePermission.status &&
          request.resource.data.spectatePermission.expiresAt == resource.data.spectatePermission.expiresAt &&
          request.resource.data.spectatePermission.grantedAt == resource.data.spectatePermission.grantedAt
        );
      
      // DELETE: Disallow hard deletes. Soft deletes are handled via an 'update'.
      allow delete: if false;

      // -- User Subcollections --
      match /quotes/{quoteId} {
        allow read: if isOwner(userId) || canSpectate(userId);
        allow write: if isOwner(userId);
      }
      
      match /dailyGoals/{goalId} {
        allow read: if isOwner(userId) || canSpectate(userId);
        allow write: if isOwner(userId);
      }

      match /mistakes/{mistakeId} {
        allow read: if isOwner(userId) || canSpectate(userId);
        allow write: if isOwner(userId);
      }
    }

    match /userProgress/{userId} {
      allow read: if isOwner(userId) || canSpectate(userId);
      allow write: if isOwner(userId);
    }
    
    match /syllabuses/{syllabusId} {
      allow write: if isAdmin();
      allow read: if isSignedIn();
    }
    
    match /spectateLogs/{logId} {
        allow create: if isAdmin();
        allow read, write, delete: if false;
    }

    match /unbanRequests/{requestId} {
        // CREATE: A user can create their own unban request.
        allow create: if isOwner(request.resource.data.userId);
        
        // LIST, GET, UPDATE, DELETE: Admins and sub-admins can manage unban requests.
        allow list, get, update, delete: if hasAdminPrivileges();
    }

    match /contactSubmissions/{submissionId} {
        // CREATE: Anyone can submit the contact form.
        allow create: if true;
        
        // Admins and sub-admins can read, list, update (e.g., mark as read), and delete submissions.
        allow read, list, update, delete: if hasAdminPrivileges();
    }

    match /groups/{groupId} {
      function isGroupMember() {
        return isSignedIn() && resource.data.memberIds.hasAny([request.auth.uid]);
      }
      function isGroupAdmin() {
        return isSignedIn() && resource.data.adminId == request.auth.uid;
      }
      function isCreatingGroupAdmin() {
         return isSignedIn() && request.resource.data.adminId == request.auth.uid;
      }

      allow get: if isGroupMember() || canSpectate(get(/databases/$(database)/documents/groups/$(groupId)).data.adminId);
      allow list: if isSignedIn(); // Secured by client query `array-contains`
      allow create: if isCreatingGroupAdmin() && request.auth.uid in request.resource.data.memberIds;
      allow update: if isGroupAdmin() || (isGroupMember() && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastMessage', 'lastMessageAt']));
      allow delete: if isGroupAdmin();

      match /messages/{messageId} {
          function isParentGroupMember() {
            // Must use `get` to check parent document for single doc operations.
            return isSignedIn() && get(/databases/$(database)/documents/groups/$(groupId)).data.memberIds.hasAny([request.auth.uid]);
          }
          // GET/CREATE: You must be a member of the parent group. This can use get().
          allow get, create: if isParentGroupMember();

          // LIST: The rule can't use get() for list queries. We allow any signed-in user.
          // Client queries MUST be constructed securely (e.g., only query for groups the user is in).
          allow list: if isSignedIn();
          
          // No one can update or delete messages.
          allow update, delete: if false;
      }
    }

    match /posts/{postId} {
      function isPostOwner() {
        return isOwner(resource.data.userId);
      }
      
      function canSpectatePostOwner() {
          return canSpectate(resource.data.userId);
      }

      allow list: if isSignedIn();
      allow get: if isSignedIn() || canSpectatePostOwner();
      allow create: if isOwner(request.resource.data.userId);
      // Allow anyone to like (update likes array), but only owner to edit caption
      allow update: if (isSignedIn() && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likes'])) ||
                      (isPostOwner() && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['caption']));
      allow delete: if isPostOwner();

      match /comments/{commentId} {
        function isCommentOwner() {
          return isOwner(resource.data.userId);
        }
        
        allow list, get: if isSignedIn() || canSpectate(get(/databases/$(database)/documents/posts/$(postId)).data.userId);
        allow create: if isOwner(request.resource.data.userId);
        allow update: if false; // Comments are immutable
        // Owner of comment OR owner of post can delete comments
        allow delete: if isCommentOwner() || isOwner(get(/databases/$(database)/documents/posts/$(postId)).data.userId);
      }
    }
    
    match /follows/{followId} {
        // CREATE: A user can create a follow document if they are the follower.
        allow create: if isSignedIn() && request.resource.data.followerId == request.auth.uid;

        // READ: Any signed-in user can read follow relationships.
        allow read: if isSignedIn();

        // DELETE: A user can only delete a follow document where they are the follower.
        allow delete: if isSignedIn() && get(/databases/$(database)/documents/follows/$(followId)).data.followerId == request.auth.uid;
        
        // UPDATE: Disallow updates.
        allow update: if false;
    }

    match /premiumCodes/{codeId} {
      // Admins can create and list codes.
      allow create, list: if isAdmin();
      // Any signed-in user can get a document if they know the ID.
      allow get: if isSignedIn();
      // Any signed-in user can "consume" a code by deleting it as part of a transaction.
      allow delete: if isSignedIn();
    }
  }
}
